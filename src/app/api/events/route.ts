import axios from 'axios';
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;

  // Convert searchParams to object to pass all filters to the backend
  const params: Record<string, string> = {};

  // Extrair todos os parâmetros e adicionar ao objeto params
  searchParams.forEach((value, key) => {
    params[key] = value;
  });

  // Parâmetros específicos para garantir que estejam sendo enviados
  const limit = searchParams.get('limit');
  const offset = searchParams.get('offset');
  const capacities = searchParams.get('capacities');
  const territories = searchParams.get('territories');
  const location_type = searchParams.get('location_type');
  const start_date = searchParams.get('start_date');
  const end_date = searchParams.get('end_date');
  const organization_id = searchParams.get('organization_id');

  // Garantir que todos os parâmetros estejam incluídos
  if (limit) params.limit = limit;
  if (offset) params.offset = offset;
  if (capacities) params.capacities = capacities;
  if (territories) params.territories = territories;
  if (location_type) {
    params.location_type = location_type;
    console.log('API - Enviando location_type:', location_type);
  }
  if (start_date) params.start_date = start_date;
  if (end_date) params.end_date = end_date;
  if (organization_id) params.organization_id = organization_id;

  try {
    const response = await axios.get(`${process.env.BASE_URL}/events/`, {
      params,
    });

    // Return both the results and the total count
    return NextResponse.json({
      results: response.data.results || [],
      count: response.data.count || response.data.results?.length || 0,
    });
  } catch (error: any) {
    console.error('Error fetching events:', error.message, error.response?.data);
    return NextResponse.json(
      {
        error: 'Failed to fetch events',
        details: error.response?.data || error.message,
      },
      { status: error.response?.status || 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  const authHeader = request.headers.get('authorization');

  let event;
  try {
    event = await request.json();
  } catch (parseError) {
    console.error('Error parsing request body:', parseError);
    return NextResponse.json(
      {
        error: 'Invalid JSON in request body',
        details: parseError.message,
      },
      { status: 400 }
    );
  }

  // Validate required fields
  const requiredFields = ['name', 'organization', 'time_begin'];
  const missingFields = requiredFields.filter(field => !event[field]);

  if (missingFields.length > 0) {
    return NextResponse.json(
      {
        error: 'Missing required fields',
        details: `Required fields missing: ${missingFields.join(', ')}`,
      },
      { status: 400 }
    );
  }

  if (!authHeader) {
    return NextResponse.json(
      {
        error: 'Authorization header missing',
        details: 'Authorization header is required for creating events',
      },
      { status: 401 }
    );
  }

  // Clean and validate event data - only include fields that can be sent to backend
  // Default time_end to 2 hours after time_begin if not provided
  const defaultTimeEnd = event.time_end || new Date(new Date(event.time_begin).getTime() + 2 * 60 * 60 * 1000).toISOString();

  const cleanedEvent: any = {
    name: event.name,
    type_of_location: event.type_of_location || 'virtual',
    time_begin: event.time_begin,
    time_end: defaultTimeEnd,
    organization: event.organization,
    related_skills: event.related_skills || [], // Always include related_skills, default to empty array
    description: event.description || '', // Add empty description by default
  };

  // Remove problematic fields that cause 500 errors
  if (cleanedEvent.id) {
    delete cleanedEvent.id; // Auto-generated by Django
  }
  if (cleanedEvent.created_at) {
    delete cleanedEvent.created_at; // Read-only, auto-generated
  }
  if (cleanedEvent.updated_at) {
    delete cleanedEvent.updated_at; // Read-only, auto-generated
  }
  if (cleanedEvent.team) {
    delete cleanedEvent.team; // Doesn't exist in the model
  }
  if (cleanedEvent.organizations) {
    delete cleanedEvent.organizations; // Conflicts with organization field
  }

  // Add optional fields only if they have valid values
  if (event.url && event.url !== '') {
    cleanedEvent.url = event.url;
  }

  if (event.wikidata_qid && event.wikidata_qid !== '') {
    cleanedEvent.wikidata_qid = event.wikidata_qid;
  }

  if (event.image_url && event.image_url !== '') {
    cleanedEvent.image_url = event.image_url;
  }

  if (event.time_end && event.time_end !== null && event.time_end !== '') {
    cleanedEvent.time_end = event.time_end;
  }

  if (event.description && event.description !== '') {
    cleanedEvent.description = event.description;
  }

  // related_skills is already set above with default empty array,
  // but update if provided
  if (event.related_skills && Array.isArray(event.related_skills)) {
    cleanedEvent.related_skills = event.related_skills;
  }

  if (event.openstreetmap_id && event.openstreetmap_id !== null && event.openstreetmap_id !== '') {
    cleanedEvent.openstreetmap_id = event.openstreetmap_id;
  }

  try {
    const baseUrl = process.env.BASE_URL;
    const apiEndpoint = `${baseUrl}/events/`;

    const response = await axios.post(apiEndpoint, cleanedEvent, {
      headers: {
        Authorization: authHeader,
        'Content-Type': 'application/json',
      },
      timeout: 30000, // 30 seconds timeout
      validateStatus: function (status) {
        return true; // Don't throw for any status code, we'll handle it manually
      },
    });

    // Check if the response was successful
    if (response.status >= 200 && response.status < 300) {
      return NextResponse.json(response.data);
    } else {
      // Handle error responses
      return NextResponse.json(
        {
          error: 'Backend API error',
          details: response.data,
          statusCode: response.status,
          type: 'api_error',
          timestamp: new Date().toISOString(),
        },
        { status: response.status }
      );
    }
  } catch (error: any) {
    // Determine error type and log accordingly
    if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
      console.error('Network/Connection error:', error.message);

      return NextResponse.json(
        {
          error: 'Backend service unavailable',
          details: `Cannot connect to backend at ${process.env.BASE_URL}. Error: ${error.message}`,
          type: 'connection_error',
          timestamp: new Date().toISOString(),
        },
        { status: 503 } // Service Unavailable
      );
    }

    if (error.code === 'ETIMEDOUT') {
      console.error('Timeout error:', error.message);

      return NextResponse.json(
        {
          error: 'Request timeout',
          details: 'Backend request timed out after 30 seconds',
          type: 'timeout_error',
          timestamp: new Date().toISOString(),
        },
        { status: 408 } // Request Timeout
      );
    }

    console.error('Event creation error:', error.message);

    // Enhanced error response for API errors
    const errorDetails = error.response?.data || error.message;
    const statusCode = error.response?.status || 500;

    // If we have a specific backend error, pass it through
    if (error.response?.status && error.response?.data) {
      return NextResponse.json(
        {
          error: 'Backend API error',
          details: errorDetails,
          statusCode,
          type: 'api_error',
          timestamp: new Date().toISOString(),
        },
        { status: statusCode }
      );
    }

    // Generic server error
    return NextResponse.json(
      {
        error: 'Failed to create event',
        details: errorDetails,
        type: 'server_error',
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    );
  }
}
